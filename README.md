# -
假设我们要求a^b，按照朴素算法就是把a连乘b次，这样一来时间复杂度是O(b)，即是O(n)级别。但快速幂能做到O(logn)的复杂度。
快速幂这个东西比较好理解，但实现起来到不老好办，记了几次老是忘，今天把它系统的总结一下防止忘记。

　　首先，快速幂的目的就是做到快速求幂，假设我们要求a^b,按照朴素算法就是把a连乘b次，这样一来时间复杂度是O(b)也即是O(n)级别，快速幂能做到O(logn)，快了好多好多。它的原理如下：

　　假设我们要求a^b，那么其实b是可以拆成二进制的，该二进制数第i位的权为2^(i-1)，例如当b==11时，a^11=a^(2^0+2^1+2^3)

　　11的二进制是1011，11 = 2³×1 + 2²×0 + 2¹×1 + 2º×1，因此，我们将a¹¹转化为算 a^(2^0)*a^(2^1)*a^(2^3) ，看出来快的多了吧原来算11次，现在算三次，但是这三项貌似不好求的样子....不急，下面会有详细解释。
　　由于是二进制，很自然地想到用位运算这个强大的工具： &  和 >> ，&运算通常用于二进制取位操作，例如一个数 & 1 的结果就是取二进制的最末位。还可以判断奇偶x&1==0为偶，x&1==1为奇。>>运算比较单纯,二进制去掉最后一位，不多说了，先放代码再解释。
  int poww(int a,int b){
    int ans=1,base=a;
    while(b!=0){
        if(b&1!=0)
        　　ans*=base;
        base*=base;
        b>>=1;
　 }
    return ans;
    代码很短，死记也可行，但最好还是理解一下吧，其实也很好理解，以b==11为例，b=>1011,二进制从右向左算，但乘出来的顺序是 a^(2^0) * a^(2^1)  * a^(2^3)，是从左向右的。我们不断的让base*=base目的即是累乘，以便随时对ans做出贡献。

　　其中要理解base*=base这一步，看：：：base*base==base^2,下一步再乘，就是base^2*base^2==base^4,然后同理  base^4 * base4 = base^8 ,,,,, see?是不是做到了base-->base^2-->base^4-->base^8-->base^16-->base^32.......指数正是 2^i 啊，再看上面的例子，a¹¹ =  a^(2^0) * a^(2^1) * a^(2^3)，这三项是不是完美解决了，，嗯，快速幂就是这样。

　　顺便啰嗦一句，由于指数函数是爆炸增长的函数，所以很有可能会爆掉int的范围，根据题意决定是用 long long啊还是unsigned int啊还是mod某个数啊自己看着办。

　　还有，矩阵快速幂的求法唯一的区别就是*换成矩阵中的乘法，写个函数代换嘛，思想一毛一样。

分类: C/C++
}
